WIP: Project for house automation in Common Lisp: House automation bus (hab)

*** House Automation for Common Lisp

****  Motivation

I use home automation in my home. Currently utilizing [[https://www.openhab.org/][openHAB]]. While openHAB has many features and supports many devices and so on, it is also a heavy beast.

So my aim was to eventually replace openHAB. There are a few things still missing to do this. The current state of the cl-hab project lacks the following for me to be able to replace openHAB:

- support for KNX
- a REST interface
- a UI to interact with the system

**** What does cl-hab currently do

***** cl-hab consists of the following components:

- item: items are a primitive to represent the temperatur of a sensor, the state of light in your house, the state of you window being open or closed, etc.

- binding: bindings are a means to update an items value or distribute a value change to somewhere

- persistence: persistences allow to persist and load the state of items. Currently two types of persistences are supported:
    - simple-persistence that just stores the current state and can retrieve it
    - historic persistence with a support for influxdb to store each changed item value in influxdb and also retrieve values for a specific time range to calculate averages, peaks or whatever.

- rules: rules are kind of scripts that are run on certain 'triggers'. Triggers may be a change of an item value, or a cron timing.

**** How does it work

cl-hab is largely based on [[https://github.com/mdbergmann/cl-gserver][Sento]] a Common Lisp Actor Framework where features like thread-safety, queuing and an event-bus are very handy for cl-hab.

How it works is to define and combine all the mentioned primitives in a file. This file is a Common Lisp source file. The definition of the primitives (item, binding, ...) is done using pre-defined DSL (domain specific language) which largely consists of a few macros. But it is also possible to define your own macros, functions or variables.

A full production example that defines items, bindings, persistences and rules can be seen [[https://github.com/mdbergmann/cl-etaconnector/blob/master/eta-hab.lisp][here]]. This script, very much based on Common Lisp, is a full example configuration of cl-hab. At the end of the script evaluation all items, persistences and rules will start their work.

This particular example uses Common Lisp libraries like [[https://github.com/bendudson/py4cl][py4cl]] (to talk to ina219 analog 2 didital converter for a pressure sensor in a zisterne plugged to the GPIOs of a Raspberry PI 4), [[https://github.com/edicl/drakma][Drakma]] to query data of a [[https://www.shelly-support.eu/][Shelly]] power switch or [[https://github.com/snmsts/cserial-port][cserial]] to communicate with some other device to retrieve temperatur sensor data.

**** But let's go slowly

The top of the cl-hab standalone script should include this (=eval-when=) in order to make sure that dependencies are loaded properly. But this is not mandatory if you find another way of loading dependencies.

#+begin_src lisp
(eval-when (:compile-toplevel :load-toplevel :execute)
  (ql:quickload :cl-hab))  ; at least this if you don't have more
#+end_src

Next thing is that you might want to define a separate package using =defpackage=, it allows to inherit symbols using =:use= or =:import-from= that you want to use in the script.

***** Defining the global environment
The first thing cl-hab specific that should defined is the 'config'. This is done by =(defconfig)=. This expression should be before items, persistences and rules because it defines and starts the underlying actor system and sets up some other necessary structures.

***** Defining persistences
Persistences are used to persist the value of an item and to retrieve it back. The influx persistence also allows to retrieve all values of a time range.

****** Simple persistence
To define a 'simple' persistence you do:

#+begin_src lisp
  (defpersistence :simple
    (lambda (id)
      (make-simple-persistence id :storage-root-path #P"some-path")))
#+end_src

The =:simple= here is the persistence id passed along to the lambda factory function.

The only information =simple-persistence= requires is where to store the item values. Each item is stored in its own file and just stores the last value. The value plus a timestamp (=GET-UNIVERSAL-TIME=) is stored in JSON format like this:

#+begin_src
{"value":66.19999694824219,"timestamp":3907315980}
#+end_src

Under normal circumstances you don't need to deal with simple persistences directly. To retrieve a item value you'd call =ITEM:GET-VALUE=. Though it is possible to call =PERSP:FETCH= and retrieve the current value.

****** Influx persistence
A persistence that allows retrieving item values of a time range, i.e. to build daily or weekly average values, is influx. Currently only influx v2 is supported. Define such persistence like this:

#+begin_src lisp
  (defpersistence :influx
      (lambda (id)
        (make-influx-persistence
         id
         :base-url "http://your-host:8086"
         :token "your-token"
         :org "your-org"
         :bucket "your-bucket")))
#+end_src

To retrieve a range of values you can call =PERSP:FETCH= with an optional range instance. Currently only =RELATIVE-RANGE= exists.

***** Bindings
Bindings are a means to interact with sources or targets, meaning they allow interactivity with the item value.
Bindings are defined as part of an item definition and *not* on toplevel. A basic binding definition looke like this:

#+begin_src lisp
  (binding :initial-delay 5
           :delay 60
           :pull (lambda () 0) ;;pull value from somewhere
           :push (lambda (value)) ;; push to somewhere else
           :call-push-p t)
#+end_src

This binding uses =pull= function to retrieve a value, which is passed on to the item value. When to =pull= is determined by =:initial-delay= and =:delay= in seconds where the former is an 'initial delay' and the latter a repetetive delay. =:call-push-p= actually defines whether the =push= function is called when the value was updated. The =push= function can be used to push the value elsewhere if required. Both =pull= and =push= are optional. Though one of the two should be used, otherwise the binding doesn't make much sense.

Thinking further, I'd like to have bindings that are specific to pulling from http, serial, or whatever, and allow to be specified in that way. The =pull=, =push= functions are very generic but may require repetition and are not enough specialized.

See next how to define and attach bindings on items.

***** Defining items
The simplest form to define an item is:

#+begin_src lisp
  (defitem 'myitem "My Item" 'integer)
#+end_src

This defines a plain item that can hold a value. You could manually use =SET-VALUE= function to give it a value or =GET-VALUE= to retrieve its value. In some cases this is useful in 'rules'. See later.

The three parameters define an id of the item (for easier lookup), a label and a type hint. The type hint is not necessary unless you want to use influx db where under the hoods it is necessary to bring the value in the right format based on what type the value is in. Checkout [["https://github.com/mdbergmann/cl-hab/blob/main/src/persistence-influx.lisp"][influx persistence]] for which types are supported. However, even if not required it might be a good idea to define the type for clarity.

Usually you'd want to at least define an initial value. Well you can do so by:

#+begin_src lisp
  (defitem 'myitem "My Item" 'integer
    :initial-value 0)
#+end_src

****** Define and attach bindings

In many cases you want to retrieve the item value from somewhere and maybe also want to push it somewhere else once it was set. This is where bindings come in. There can be more =binding= definitions on an item but this only really makes sense if you plan to =push= to more places. An item definition with binding looks like this:

#+begin_src lisp
  (defitem 'myitem "My Item" 'integer
    :initial-value 0
    (binding :initial-delay 5
             :delay 60
             :pull (lambda () (do-some-http-get))
             :push (lambda (value) (do-some-http-post))
             :call-push-p t))
#+end_src

****** Applying persistences on the item definitions



***** Defining rules

